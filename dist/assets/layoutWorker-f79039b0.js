var u=Object.defineProperty;var w=(l,t,e)=>t in l?u(l,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):l[t]=e;var d=(l,t,e)=>(w(l,typeof t!="symbol"?t+"":t,e),e);class f{constructor(t,e,i){d(this,"viewportWidth");d(this,"viewportHeight");d(this,"fontMetrics");this.viewportWidth=t,this.viewportHeight=e,this.fontMetrics=i}getCharacterDimensions(t){const e=t*(this.fontMetrics.ascender-this.fontMetrics.descender)/this.fontMetrics.unitsPerEm;return{width:t*.6,height:e}}calculateOptimalPlacement(t,e){return t.length===0?this.placeFirstCharacter(e):this.findBestPlacement(t,e)}placeFirstCharacter(t){const e=Math.min(this.viewportWidth,this.viewportHeight)*.8;return{x:this.viewportWidth/2,y:this.viewportHeight/2,rotation:0,scale:e,score:1}}findBestPlacement(t,e){let i={x:0,y:0,rotation:0,scale:0,score:0};const a=300,r=12,s=[this.randomPlacementStrategy.bind(this),this.cornerPlacementStrategy.bind(this),this.edgePlacementStrategy.bind(this)];for(const c of s)for(let n=0;n<a/s.length;n++)for(let o=0;o<r;o++){const h=o*360/r,g=c(t),p=this.calculateMaxScale(t,e,g.x,g.y,h);p>i.scale&&(i={x:g.x,y:g.y,rotation:h,scale:p,score:p})}return i.scale<15&&(i.scale=15),i}randomPlacementStrategy(t){return{x:Math.random()*this.viewportWidth,y:Math.random()*this.viewportHeight}}cornerPlacementStrategy(t){const i=[{x:100,y:100},{x:this.viewportWidth-100,y:100},{x:100,y:this.viewportHeight-100},{x:this.viewportWidth-100,y:this.viewportHeight-100}];return i[Math.floor(Math.random()*i.length)]}edgePlacementStrategy(t){switch(Math.floor(Math.random()*4)){case 0:return{x:Math.random()*this.viewportWidth,y:50};case 1:return{x:this.viewportWidth-50,y:Math.random()*this.viewportHeight};case 2:return{x:Math.random()*this.viewportWidth,y:this.viewportHeight-50};case 3:return{x:50,y:Math.random()*this.viewportHeight};default:return{x:Math.random()*this.viewportWidth,y:Math.random()*this.viewportHeight}}}calculateMaxScale(t,e,i,a,r){const s=Math.min(this.viewportWidth,this.viewportHeight);let c=0,n=1,o=s;for(;o-n>1;){const h=(n+o)/2;this.checkCollision(t,e,i,a,r,h)?o=h:(n=h,c=h)}return c}checkCollision(t,e,i,a,r,s){const c=this.getCharacterDimensions(s),n=c.width,o=c.height;if(i-n/2<0||i+n/2>this.viewportWidth||a-o/2<0||a+o/2>this.viewportHeight)return!0;for(const h of t)if(this.charactersOverlap({x:i,y:a,scale:s,rotation:r},{x:h.x,y:h.y,scale:h.scale,rotation:h.rotation}))return!0;return!1}charactersOverlap(t,e){const i=this.getCharacterDimensions(t.scale),a=this.getCharacterDimensions(e.scale),r=t.x-e.x,s=t.y-e.y,c=Math.sqrt(r*r+s*s),n=Math.max(i.width,i.height)*.4,o=Math.max(a.width,a.height)*.4;return c<n+o}recalculateAllPlacements(t){if(t.length===0)return[];const e=[],i=t.filter(r=>!r.isComposing),a=t.filter(r=>r.isComposing);e.push(...i);for(const r of a){const s=this.calculateOptimalPlacement(e,r.char);e.push({...r,x:s.x,y:s.y,rotation:s.rotation,scale:s.scale})}return e}}let m=null;self.onmessage=function(l){const{type:t,characters:e,newChar:i,viewportWidth:a,viewportHeight:r,fontMetrics:s}=l.data;if(t==="calculate"){(!m||m.viewportWidth!==a||m.viewportHeight!==r)&&(m=new f(a,r,s));try{const n={type:"result",placement:m.calculateOptimalPlacement(e,i),characters:e};self.postMessage(n)}catch(c){console.error("Layout calculation error:",c);const o={type:"result",placement:{x:Math.random()*a,y:Math.random()*r,rotation:0,scale:50,score:0},characters:e};self.postMessage(o)}}};
