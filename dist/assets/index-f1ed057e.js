var v=Object.defineProperty;var E=(p,t,e)=>t in p?v(p,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):p[t]=e;var r=(p,t,e)=>(E(p,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))o(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const n of s.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&o(n)}).observe(document,{childList:!0,subtree:!0});function e(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function o(i){if(i.ep)return;i.ep=!0;const s=e(i);fetch(i.href,s)}})();class w{constructor(t,e,o,i){r(this,"inputElement");r(this,"onCharacterAdd");r(this,"onCharacterDelete");r(this,"onCompositionUpdate");r(this,"compositionState");this.inputElement=t,this.onCharacterAdd=e,this.onCharacterDelete=o,this.onCompositionUpdate=i,this.compositionState={text:"",isComposing:!1,characters:[]},this.setupEventListeners()}setupEventListeners(){this.inputElement.focus(),document.addEventListener("click",()=>{this.inputElement.focus()}),this.inputElement.addEventListener("compositionstart",()=>{this.compositionState.isComposing=!0}),this.inputElement.addEventListener("compositionupdate",t=>{this.handleCompositionUpdate(t.data)}),this.inputElement.addEventListener("compositionend",t=>{this.handleCompositionEnd(t.data)}),this.inputElement.addEventListener("input",t=>{if(console.log("⌨️ Input event triggered:",{value:this.inputElement.value,isComposing:this.compositionState.isComposing,inputType:t.inputType}),!this.compositionState.isComposing&&this.inputElement.value){const e=this.inputElement.value;console.log("📝 Processing input value:",e),this.inputElement.value="";for(const o of e)o&&o.trim()&&(console.log("➕ Adding character:",o),this.onCharacterAdd(o,!1));console.log("🧹 Input processing completed")}}),this.inputElement.addEventListener("keydown",t=>{t.key==="Escape"?this.clearComposition():t.key==="Backspace"||t.key==="Delete"?this.compositionState.isComposing||(t.preventDefault(),this.onCharacterDelete()):t.key==="F5"||t.metaKey&&t.key==="r"?(t.preventDefault(),this.clearAll()):t.metaKey&&t.key==="z"&&t.preventDefault()})}handleCompositionUpdate(t){if(t){this.clearCompositionCharacters(),this.compositionState.text=t,this.compositionState.characters=[];for(let e=0;e<t.length;e++){const o=t[e];if(o.trim()){const s={id:`composing-${Date.now()}-${e}`,char:o,x:0,y:0,rotation:0,scale:1,isComposing:!0};this.compositionState.characters.push(s),this.onCharacterAdd(o,!0)}}this.onCompositionUpdate(this.compositionState)}}handleCompositionEnd(t){if(!t){this.clearComposition();return}this.clearCompositionCharacters();for(const e of t)e.trim()&&this.onCharacterAdd(e,!1);this.clearComposition(),this.inputElement.value=""}clearCompositionCharacters(){this.onCompositionUpdate({text:"",isComposing:!1,characters:[]})}clearComposition(){this.compositionState={text:"",isComposing:!1,characters:[]},this.inputElement.value=""}clearAll(){this.clearComposition(),document.dispatchEvent(new CustomEvent("clearAll"))}focus(){this.inputElement.focus()}}class x{constructor(t){r(this,"svg");r(this,"characters");this.svg=t,this.characters=new Map,this.setupSVG()}setupSVG(){this.svg.setAttribute("width","100%"),this.svg.setAttribute("height","100%"),this.svg.setAttribute("viewBox",`0 0 ${window.innerWidth} ${window.innerHeight}`),window.addEventListener("resize",()=>{this.svg.setAttribute("viewBox",`0 0 ${window.innerWidth} ${window.innerHeight}`)})}addOrUpdateCharacter(t){if(console.log("🖼️ Renderer: addOrUpdateCharacter called",{char:t.char,x:t.x,y:t.y,scale:t.scale,rotation:t.rotation,isComposing:t.isComposing}),t.scale<=0||!isFinite(t.scale)){console.log("⚠️ Skipping render for invalid scale:",t.scale);return}const e=this.characters.get(t.id);e?(console.log("🔄 Updating existing character"),this.updateCharacterElement(e,t)):(console.log("✨ Creating new character element"),this.createCharacterElement(t)),this.characters.set(t.id,t),console.log("✅ Character rendered successfully with scale:",t.scale)}createCharacterElement(t){const e=document.createElementNS("http://www.w3.org/2000/svg","text");e.setAttribute("id",t.id),e.setAttribute("x",t.x.toString()),e.setAttribute("y",t.y.toString()),e.setAttribute("font-family",'Helvetica, "Hiragino Kaku Gothic ProN", "ヒラギノ角ゴ ProN W3", Meiryo, sans-serif'),e.setAttribute("font-size",t.scale.toString()),e.setAttribute("text-anchor","middle"),e.setAttribute("dominant-baseline","central"),e.setAttribute("fill",t.isComposing?"#808080":"#FFFFFF"),e.setAttribute("user-select","none"),e.textContent=t.char,t.rotation!==0&&e.setAttribute("transform",`rotate(${t.rotation} ${t.x} ${t.y})`),e.style.opacity="0",this.svg.appendChild(e),requestAnimationFrame(()=>{e.style.transition="opacity 0.3s ease, transform 0.3s ease",e.style.opacity="1"}),t.element=e}updateCharacterElement(t,e){const o=t.element;if(!o)return;(t.x!==e.x||t.y!==e.y||t.rotation!==e.rotation||t.scale!==e.scale)&&(o.style.transition="all 0.3s ease"),o.setAttribute("x",e.x.toString()),o.setAttribute("y",e.y.toString()),o.setAttribute("font-size",e.scale.toString()),o.setAttribute("fill",e.isComposing?"#808080":"#FFFFFF"),e.rotation!==0?o.setAttribute("transform",`rotate(${e.rotation} ${e.x} ${e.y})`):o.removeAttribute("transform"),t.char!==e.char&&(o.textContent=e.char),t.isComposing!==e.isComposing&&o.setAttribute("fill",e.isComposing?"#808080":"#FFFFFF")}removeCharacter(t){const e=this.characters.get(t);!e||!e.element||(e.element.style.transition="opacity 0.2s ease",e.element.style.opacity="0",setTimeout(()=>{e.element&&e.element.parentNode&&e.element.parentNode.removeChild(e.element),this.characters.delete(t)},200))}clearComposingCharacters(){const t=[];this.characters.forEach((e,o)=>{e.isComposing&&t.push(o)}),t.forEach(e=>this.removeCharacter(e))}confirmComposingCharacters(){this.characters.forEach(t=>{t.isComposing&&(t.isComposing=!1,t.element&&t.element.setAttribute("fill","#FFFFFF"))})}updateMultipleCharacters(t){t.forEach(e=>{this.addOrUpdateCharacter(e)})}clear(){this.characters.forEach((t,e)=>{this.removeCharacter(e)}),this.characters.clear()}getCharacterCount(){return this.characters.size}getAllCharacters(){return Array.from(this.characters.values())}}class A{constructor(t,e,o){r(this,"viewportWidth");r(this,"viewportHeight");r(this,"fontMetrics");this.viewportWidth=t,this.viewportHeight=e,this.fontMetrics=o}getCharacterDimensions(t){const e=t*(this.fontMetrics.ascender-this.fontMetrics.descender)/this.fontMetrics.unitsPerEm;return{width:t*.7,height:e}}calculateOptimalPlacement(t,e){if(console.log(`🎯 calculateOptimalPlacement called for "${e}"`),console.log(`📊 Existing characters: ${t.length}`),console.log(`📐 Viewport: ${this.viewportWidth} x ${this.viewportHeight}`),t.length===0)return console.log("🎯 First character detected, placing at center"),this.placeFirstCharacter(e);console.log("🎯 Finding best placement for subsequent character");const o=this.findBestPlacement(t,e);return console.log("🎯 calculateOptimalPlacement result:",o),o}placeFirstCharacter(t){const e=Math.min(this.viewportWidth,this.viewportHeight)*.8;return console.log(`📐 First character placement: scale=${e}, viewport=${this.viewportWidth}x${this.viewportHeight}`),{x:this.viewportWidth/2,y:this.viewportHeight/2,rotation:0,scale:e,score:1}}findBestPlacement(t,e){console.log("🔍 findBestPlacement starting...");let o={x:this.viewportWidth/2,y:this.viewportHeight/2,rotation:0,scale:10,score:0};const i=200,s=8;console.log(`🎲 Testing ${i} random positions with ${s} rotation steps each`);for(let n=0;n<i;n++){const a=Math.random()*this.viewportWidth,c=Math.random()*this.viewportHeight;for(let l=0;l<s;l++){const d=l*360/s,h=this.calculateMaxScale(t,e,a,c,d);h>o.scale&&(o={x:a,y:c,rotation:d,scale:h,score:h},console.log(`🎯 New best placement found: scale=${h.toFixed(1)} at (${a.toFixed(1)}, ${c.toFixed(1)}) rot=${d}°`))}}return o.scale<15&&(console.log(`⚠️ Scale too small (${o.scale}), setting to minimum 15`),o.scale=15),console.log(`📐 Final placement: scale=${o.scale.toFixed(1)}, pos=(${o.x.toFixed(1)}, ${o.y.toFixed(1)}), rot=${o.rotation.toFixed(1)}°`),o}generateGridPositions(t){const e=[],o=this.viewportWidth/t,i=this.viewportHeight/t;for(let s=0;s<=t;s++)for(let n=0;n<=t;n++)e.push({x:s*o,y:n*i});return e}calculateMaxScale(t,e,o,i,s){const n=Math.min(this.viewportWidth,this.viewportHeight)*.8;let a=0,c=10,l=n;for(let d=0;d<15;d++){const h=(c+l)/2;if(this.checkCollision(t,e,o,i,s,h)?l=h:(c=h,a=h),l-c<2)break}return a}checkCollision(t,e,o,i,s,n){const a=this.getCharacterDimensions(n),c=a.width,l=a.height,d=s*Math.PI/180,h=Math.abs(Math.cos(d)),g=Math.abs(Math.sin(d)),C=c*h+l*g,y=c*g+l*h,u=20;if(o-C/2<u||o+C/2>this.viewportWidth-u||i-y/2<u||i+y/2>this.viewportHeight-u)return!0;for(const m of t)if(this.charactersOverlap({x:o,y:i,scale:n,rotation:s},{x:m.x,y:m.y,scale:m.scale,rotation:m.rotation}))return!0;return!1}charactersOverlap(t,e){const o=this.getCharacterDimensions(t.scale),i=this.getCharacterDimensions(e.scale),s=t.x-e.x,n=t.y-e.y,a=Math.sqrt(s*s+n*n),c=this.getEffectiveRadius(o,t.rotation),l=this.getEffectiveRadius(i,e.rotation),d=.9;return a<(c+l)*d}getEffectiveRadius(t,e){const o=e*Math.PI/180,i=Math.abs(Math.cos(o)),s=Math.abs(Math.sin(o)),n=t.width*i+t.height*s,a=t.width*s+t.height*i;return Math.max(n,a)*.5}recalculateAllPlacements(t){if(t.length===0)return[];const e=[],o=t.filter(s=>!s.isComposing),i=t.filter(s=>s.isComposing);console.log(`🔄 Recalculating placements: ${o.length} confirmed, ${i.length} composing`),e.push(...o);for(const s of i){console.log(`📍 Recalculating placement for composing char: ${s.char}`);const n=this.calculateOptimalPlacement(e,s.char),a={...s,x:n.x,y:n.y,rotation:n.rotation,scale:n.scale};e.push(a),console.log("✅ Composing char placed:",a)}return e}}class b{constructor(){r(this,"renderer");r(this,"inputManager");r(this,"layoutWorker");r(this,"nestingAlgorithm");r(this,"characters");r(this,"pendingCalculations");r(this,"fontMetrics");r(this,"isInitialized",!1);this.characters=new Map,this.pendingCalculations=new Set,this.fontMetrics={unitsPerEm:1e3,ascender:800,descender:-200},this.initializeApp()}async initializeApp(){try{await this.initializeComponents(),await this.loadFonts(),this.hideLoading(),this.isInitialized=!0,console.log("Typographic Nesting Art Generator initialized")}catch(t){console.error("Initialization failed:",t),this.showError("初期化に失敗しました。ページを再読み込みしてください。")}}async initializeComponents(){const t=document.getElementById("text-canvas");if(!t)throw new Error("Canvas element not found");this.renderer=new x(t);const e=document.getElementById("input-handler");if(!e)throw new Error("Input element not found");this.inputManager=new w(e,(o,i)=>this.handleCharacterInput(o,i),()=>this.handleCharacterDelete(),o=>this.handleCompositionUpdate(o)),console.log("🔧 Using synchronous calculation (worker disabled)..."),this.nestingAlgorithm=new A(window.innerWidth,window.innerHeight,this.fontMetrics),document.addEventListener("clearAll",()=>{this.clearAll()}),console.log("✅ Components initialized successfully")}async loadFonts(){await document.fonts.ready}hideLoading(){const t=document.getElementById("loading");t&&(t.style.display="none");const e=document.getElementById("instructions");e&&(e.style.opacity="1",setTimeout(()=>{e&&(e.style.opacity="0.3")},5e3))}showError(t){const e=document.getElementById("loading");e&&(e.textContent=t,e.style.color="#ff6b6b")}handleCharacterInput(t,e){if(console.log("🎯 Character input received:",{char:t,isComposing:e,isInitialized:this.isInitialized,currentCharCount:this.characters.size,pendingCalculations:this.pendingCalculations.size}),!this.isInitialized){console.log("❌ App not initialized yet");return}const o=e?`composing-${Date.now()}-${Math.random()}`:`confirmed-${Date.now()}-${Math.random()}`,i={id:o,char:t,x:0,y:0,rotation:0,scale:1,isComposing:e};if(console.log("📝 Adding character to map:",i),console.log("📊 Characters before add:",this.characters.size),this.characters.set(o,i),console.log("📊 Characters after add:",this.characters.size),this.characters.size===1){const s=Math.min(window.innerWidth,window.innerHeight)*.8;i.x=window.innerWidth/2,i.y=window.innerHeight/2,i.scale=s,i.rotation=0,this.renderer.addOrUpdateCharacter(i),console.log("🎨 First character rendered at full size:",i),this.updateCharacterCount()}else console.log("🧮 Calculating optimal placement for character:",i.char),console.log("🔍 Current characters in map:",Array.from(this.characters.values()).map(s=>({char:s.char,x:s.x,y:s.y,scale:s.scale}))),this.calculateLayout(i)}handleCharacterDelete(){if(!this.isInitialized){console.log("❌ App not initialized yet");return}if(console.log("🗑️ Delete key pressed, current character count:",this.characters.size),this.characters.size===0){console.log("ℹ️ No characters to delete");return}let t=null,e=null,o=0;if(this.characters.forEach((i,s)=>{const n=s.match(/-(\d+)-/);if(n){const a=parseInt(n[1]);a>o&&(o=a,t=i,e=s)}}),t!==null&&e!==null){const i=t;console.log("🗑️ Deleting last character:",{id:e,char:i.char,isComposing:i.isComposing}),this.renderer.removeCharacter(e),this.characters.delete(e),this.pendingCalculations.delete(e),this.updateCharacterCount(),console.log("✅ Character deleted successfully, remaining count:",this.characters.size)}else console.log("⚠️ Could not find last character to delete")}handleCompositionUpdate(t){if(this.isInitialized)if(console.log("🔄 Composition state update:",t),t.isComposing)console.log("✏️ IME composing, current text:",t.text);else{console.log("🧹 Clearing composing characters"),this.renderer.clearComposingCharacters();const e=[];this.characters.forEach((o,i)=>{o.isComposing&&e.push(i)}),console.log("🗑️ Removing",e.length,"composing characters"),e.forEach(o=>{this.characters.delete(o),this.pendingCalculations.delete(o)}),this.updateCharacterCount()}}calculateLayout(t){if(console.log("🧮 Calculating layout SYNCHRONOUSLY for:",t),this.pendingCalculations.has(t.id)){console.log("⏳ Calculation already pending for:",t.id);return}this.pendingCalculations.add(t.id),console.log("🔄 Starting synchronous calculation");try{const e=Array.from(this.characters.values()).filter(n=>n.id!==t.id);console.log("📊 Existing characters for algorithm:",e.map(n=>({char:n.char,x:n.x,y:n.y,scale:n.scale})));const o=performance.now(),i=this.nestingAlgorithm.calculateOptimalPlacement(e,t.char),s=performance.now();console.log("✅ Synchronous calculation completed in",(s-o).toFixed(2),"ms"),console.log("📍 Placement result:",i),this.applyLayoutResult(t.id,i)}catch(e){console.error("💥 Synchronous layout calculation error:",e);const o={x:window.innerWidth/2,y:window.innerHeight/2,rotation:Math.random()*360,scale:50,score:0};console.log("🔄 Using fallback placement:",o),this.applyLayoutResult(t.id,o)}}applyLayoutResult(t,e){const o=this.characters.get(t);if(!o){console.log("❌ No target character found for result:",t);return}console.log("✅ Applying layout to character:",o.id,o.char),console.log("📍 Layout result details:",{before:{x:o.x,y:o.y,scale:o.scale,rotation:o.rotation},after:{x:e.x,y:e.y,scale:e.scale,rotation:e.rotation}}),this.pendingCalculations.delete(o.id),o.x=e.x,o.y=e.y,o.rotation=e.rotation,o.scale=e.scale,console.log("🎨 Final character placement:",{char:o.char,x:o.x,y:o.y,rotation:o.rotation,scale:o.scale}),console.log("🖼️ About to render character with scale:",o.scale),this.renderer.addOrUpdateCharacter(o),console.log("✅ Character rendered successfully"),this.updateCharacterCount(),o.isComposing||this.recalculateComposingCharacters(),this.logPerformanceMetrics()}logPerformanceMetrics(){this.characters.size%10===0&&console.log(`Performance: ${this.characters.size} characters, ${this.pendingCalculations.size} pending calculations`)}updateCharacterCount(){const t=document.getElementById("char-count"),e=document.getElementById("performance");if(t){const o=Array.from(this.characters.values()).filter(s=>!s.isComposing).length,i=Array.from(this.characters.values()).filter(s=>s.isComposing).length;t.textContent=`Characters: ${o}${i>0?` (+${i} composing)`:""}`}if(e){const o=this.pendingCalculations.size,i=o>5?"Calculating...":o>2?"Good":"Excellent";e.textContent=`Performance: ${i}`}}recalculateComposingCharacters(){const t=[];this.characters.forEach(e=>{e.isComposing&&t.push(e)}),t.forEach(e=>{this.calculateLayout(e)})}clearAll(){this.renderer.clear(),this.characters.clear(),this.pendingCalculations.clear(),this.updateCharacterCount(),console.log("All characters cleared")}destroy(){this.renderer.clear(),this.characters.clear()}}let f;document.addEventListener("DOMContentLoaded",()=>{f=new b});window.addEventListener("beforeunload",()=>{f&&f.destroy()});
